/**************************************************************************************************
 * Copyright VaxCare (c) 2022.                                                                    *
 **************************************************************************************************/

package com.vaxcare.vaxhub.model.appointment

import androidx.room.Entity
import androidx.room.Ignore
import androidx.room.PrimaryKey
import androidx.room.Relation
import com.squareup.moshi.Json
import com.squareup.moshi.JsonClass
import com.vaxcare.vaxhub.core.annotation.LocalTime
import com.vaxcare.vaxhub.model.CallToAction
import com.vaxcare.vaxhub.model.enums.ShotStatus
import java.time.LocalDateTime

/**
 * Interface to dictate what properties should exist for an EncounterState object
 *
 * @property id autogenerated primary key
 * @property appointmentId id of the associated appointment
 * @property shotStatus ShotStatus value
 * @property isClosed boolean is appointment closed
 * @property createdUtc Created date
 * @property messages List of appointment EntityState messaging
 */
interface EncounterState<T : EncounterMessage> {
    val id: Int
    var appointmentId: Int
    val shotStatus: ShotStatus
    val isClosed: Boolean
    val createdUtc: LocalDateTime
    var messages: List<T>
}

/**
 * DTO representation of EncounterState object - use this for all UI logic
 *
 * @property id autogenerated primary key
 * @property appointmentId id of the associated appointment
 * @property shotStatus ShotStatus value
 * @property isClosed boolean is appointment closed
 * @property createdUtc Created date
 * @property messages List of appointment EntityState messaging
 */
data class EncounterStateDto(
    override val id: Int = 0,
    override var appointmentId: Int = 0,
    override val shotStatus: ShotStatus,
    override val isClosed: Boolean,
    override val createdUtc: LocalDateTime,
    @Relation(parentColumn = "id", entityColumn = "appointmentId")
    override var messages: List<EncounterMessageEntity>
) : EncounterState<EncounterMessageEntity> {
    companion object {
        fun fromEncounterState(encounterState: EncounterState<*>?) =
            encounterState?.let {
                EncounterStateDto(
                    id = it.id,
                    appointmentId = it.appointmentId,
                    shotStatus = it.shotStatus,
                    isClosed = it.isClosed,
                    createdUtc = it.createdUtc,
                    messages = EncounterMessageEntity.fromEncounterMessage(it.messages)
                )
            }
    }

    /**
     * Returns true if any messages have any missing CTA
     */
    val hasMissingData: Boolean
        get() = messages.any { it.callToAction in CallToAction.ctaMissingInfo }

    /**
     * Returns true if any messages have demographics missing CTA
     */
    val hasMissingDemoInfo: Boolean
        get() = messages.any { it.callToAction in CallToAction.ctaMissingDemoInfo }

    /**
     * Returns true if any messages have payer missing CTA
     */
    val hasMissingPayerInfo: Boolean
        get() = messages.any { it.callToAction in CallToAction.ctaMissingPayerInfo }

    /**
     * Get the primary message of the Vaccine serviceType message
     */
    val vaccinePrimaryMessage: String?
        get() = vaccineMessage?.primaryMessage

    /**
     * Get the secondary message of the Vaccine serviceType message
     */
    val vaccineSecondaryMessage: String?
        get() = vaccineMessage?.secondaryMessage

    /**
     * Get the message object for Vaccine serviceType
     */
    val vaccineMessage: EncounterMessageEntity?
        get() = messages.firstOrNull { it.serviceType == AppointmentServiceType.VACCINE }

    /**
     * Get the message object for the MedD serviceType
     */
    val medDMessage: EncounterMessageEntity?
        get() = messages.firstOrNull { it.serviceType == AppointmentServiceType.MEDD }
}

/**
 * Json representation of EncounterState object for moshi interaction
 *
 * @property id autogenerated primary key
 * @property appointmentId id of the associated appointment
 * @property shotStatus ShotStatus value
 * @property isClosed boolean is appointment closed
 * @property createdUtc Created date
 * @property messages List of appointment EntityState messages
 */
@JsonClass(generateAdapter = true)
data class EncounterStateJson(
    override val id: Int = 0,
    override var appointmentId: Int = 0,
    @Json(name = "shotStatus") override val shotStatus: ShotStatus,
    @Json(name = "isClosed") override val isClosed: Boolean,
    @LocalTime @Json(name = "createdUtc") override val createdUtc: LocalDateTime,
    @Json(name = "messages") override var messages: List<EncounterMessageJson>
) : EncounterState<EncounterMessageJson>

/**
 * Entity representation of EncounterState for room db interaction
 *
 * @property id autogenerated primary key
 * @property appointmentId id of the associated appointment
 * @property shotStatus ShotStatus value
 * @property isClosed boolean is appointment closed
 * @property createdUtc Created date
 * @property messages List of appointment EntityState messages
 */
@Entity(tableName = "EncounterState")
data class EncounterStateEntity(
    @PrimaryKey(autoGenerate = true) override val id: Int = 0,
    override var appointmentId: Int,
    override val shotStatus: ShotStatus,
    override val isClosed: Boolean,
    override val createdUtc: LocalDateTime
) : EncounterState<EncounterMessageEntity> {
    @Ignore
    override var messages: List<EncounterMessageEntity> = listOf()

    companion object {
        fun fromEncounterState(encounterState: EncounterState<*>?) =
            encounterState?.let {
                EncounterStateEntity(
                    id = it.id,
                    appointmentId = it.appointmentId,
                    shotStatus = it.shotStatus,
                    isClosed = it.isClosed,
                    createdUtc = it.createdUtc
                ).apply {
                    messages = EncounterMessageEntity.fromEncounterMessage(it.messages)
                }
            }
    }

    /**
     * Returns true if any messages have any missing CTA
     */
    val hasMissingData: Boolean
        get() = messages.any { it.callToAction in CallToAction.ctaMissingInfo }

    /**
     * Returns true if any messages have demographics missing CTA
     */
    val hasMissingDemoInfo: Boolean
        get() = messages.any { it.callToAction in CallToAction.ctaMissingDemoInfo }

    /**
     * Returns true if any messages have payer missing CTA
     */
    val hasMissingPayerInfo: Boolean
        get() = messages.any { it.callToAction in CallToAction.ctaMissingPayerInfo }

    /**
     * Get the primary message of the Vaccine serviceType message
     */
    val vaccinePrimaryMessage: String?
        get() = vaccineMessage?.primaryMessage

    /**
     * Get the secondary message of the Vaccine serviceType message
     */
    val vaccineSecondaryMessage: String?
        get() = vaccineMessage?.secondaryMessage

    /**
     * Get the message object for Vaccine serviceType if it exists,
     * if not return the first message object
     */
    val vaccineMessage: EncounterMessageEntity?
        get() = messages.firstOrNull { it.serviceType == AppointmentServiceType.VACCINE }
            ?: messages.firstOrNull()

    /**
     * Get the message object for the MedD serviceType
     */
    val medDMessage: EncounterMessageEntity?
        get() = messages.firstOrNull { it.serviceType == AppointmentServiceType.MEDD }

    val larcMessage: EncounterMessageEntity?
        get() = messages.firstOrNull { it.serviceType == AppointmentServiceType.LARC }
}
