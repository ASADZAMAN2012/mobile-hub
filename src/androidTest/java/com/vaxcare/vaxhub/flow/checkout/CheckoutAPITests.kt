/**************************************************************************************************
 * Copyright VaxCare (c) 2025.                                                                    *
 **************************************************************************************************/

package com.vaxcare.vaxhub.flow.checkout

import androidx.hilt.work.HiltWorkerFactory
import androidx.test.core.app.ActivityScenario
import androidx.test.ext.junit.runners.AndroidJUnit4
import androidx.test.filters.LargeTest
import com.vaxcare.vaxhub.BuildConfig
import com.vaxcare.vaxhub.TestWorkManagerHelper
import com.vaxcare.vaxhub.common.HomeScreenUtil
import com.vaxcare.vaxhub.common.PatientUtil
import com.vaxcare.vaxhub.common.StorageUtil
import com.vaxcare.vaxhub.data.TestPartners
import com.vaxcare.vaxhub.data.TestPatients
import com.vaxcare.vaxhub.data.TestProducts
import com.vaxcare.vaxhub.data.TestSites
import com.vaxcare.vaxhub.flow.TestsBase
import com.vaxcare.vaxhub.mock.BaseMockDispatcher
import com.vaxcare.vaxhub.model.AppointmentCheckout
import com.vaxcare.vaxhub.model.CheckInVaccination
import com.vaxcare.vaxhub.model.PatientPostBody
import com.vaxcare.vaxhub.model.PaymentInformationRequestBody
import com.vaxcare.vaxhub.model.PaymentMode
import com.vaxcare.vaxhub.model.appointment.PhoneContactConsentStatus
import com.vaxcare.vaxhub.model.enums.RiskFactor
import com.vaxcare.vaxhub.service.UserSessionService
import com.vaxcare.vaxhub.ui.PermissionsActivity
import com.vaxcare.vaxhub.web.PatientsApi
import com.vaxcare.vaxhub.web.WebServer
import com.vaxcare.core.storage.preference.LocalStorage
import dagger.hilt.android.testing.HiltAndroidRule
import dagger.hilt.android.testing.HiltAndroidTest
import kotlinx.coroutines.runBlocking
import okhttp3.mockwebserver.MockResponse
import okhttp3.mockwebserver.RecordedRequest
import org.junit.After
import org.junit.Assert
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import retrofit2.HttpException
import java.time.LocalDateTime
import javax.inject.Inject

/**
 * API tests for the checkout process using X-VaxHub-Identifier approach
 *
 * AUTHENTICATION APPROACH:
 * These tests use a simple, fast authentication method that bypasses UI login:
 * 
 * 1. X-VaxHub-Identifier Header:
 *    - Auto-generated Base64 encoded JSON with partner, clinic, device, tablet info
 *    - Added automatically by VaxHubIdentifier interceptor
 *    - NEVER EXPIRES - can be reused forever
 *    - Generated by calling localStorage.saveSetup(partnerId, clinicId)
 * 
 * 2. UserSessionId Header:
 *    - Simple UUID generated by userSessionService.generateAndCacheNewUserSessionId()
 *    - Added automatically by VaxHubIdentifier interceptor
 *    - Created fresh in @Before for each test
 * 
 * 3. No UI Login Required:
 *    - No need to call homeScreenUtil.loginAsTestPartner()
 *    - No need to call homeScreenUtil.tapHomeScreenAndPinIn()
 *    - Tests run much faster without UI interaction
 * 
 * TEST COVERAGE:
 * - Creating appointments via API
 * - Performing checkout operations
 * - Verifying checkout completion
 * - Testing various checkout scenarios (single/multiple vaccines, payment modes, etc.)
 * - Testing high-risk patients, pregnancy, VFC, self-pay, etc.
 */
@HiltAndroidTest
@RunWith(AndroidJUnit4::class)
@LargeTest
class CheckoutAPITests : TestsBase() {

    @get:Rule
    var hiltRule = HiltAndroidRule(this)

    @Inject
    lateinit var workerFactory: HiltWorkerFactory

    @Inject
    lateinit var storageUtil: StorageUtil

    @Inject
    lateinit var patientsApi: PatientsApi

    @Inject
    lateinit var userSessionService: UserSessionService
    
    @Inject
    lateinit var webServer: com.vaxcare.vaxhub.web.WebServer
    
    @Inject
    lateinit var localStorage: com.vaxcare.core.storage.preference.LocalStorage

    private val testWorkManagerHelper = TestWorkManagerHelper()
    private lateinit var scenario: ActivityScenario<PermissionsActivity>
    private val patientUtil = PatientUtil()
    private val homeScreenUtil = HomeScreenUtil()

    // Test data
    private val testPartner = TestPartners.RprdCovidPartner
    private val testProductVaricella = TestProducts.Varicella
    private val testProductAdacel = TestProducts.Adacel
    private val testProductPPSV23 = TestProducts.PPSV23
    private val testSite = TestSites.RightArm

    @Before
    fun setUp(): Unit = runBlocking {
        hiltRule.inject()
        // Initialize WorkManager for API tests
        testWorkManagerHelper.initializeWorkManager(workerFactory)
        // Launch minimal activity for EntryPoint access (required for PatientUtil)
        scenario = ActivityScenario.launch(PermissionsActivity::class.java)
        
        // Wait for activity to be ready
        Thread.sleep(1000)
        
        // Setup partner and clinic (this generates X-VaxHub-Identifier automatically)
        setupPartnerAndClinic(testPartner)
        
        // Create user session (generates UserSessionId)
        userSessionService.generateAndCacheNewUserSessionId()
        
        // Setup mock server for local build type
        if (BuildConfig.BUILD_TYPE == "local") {
            registerMockServerDispatcher(CheckoutAPITestsDispatcher())
        }
        
        val sessionId = userSessionService.getCurrentUserSessionId()
        val vaxHubIdentifier = localStorage.getHeaderIdentifier()
        
        println("‚úÖ Setup complete:")
        println("   - Partner ID: ${testPartner.partnerID}")
        println("   - Clinic ID: ${testPartner.clinicID}")
        println("   - Session ID: $sessionId")
        println("   - X-VaxHub-Identifier: $vaxHubIdentifier")
        println("   - X-VaxHub-Identifier (first 50 chars): ${vaxHubIdentifier.take(50)}...")
        
        // Optionally decode and log the contents
        try {
            val decoded = String(android.util.Base64.decode(vaxHubIdentifier, android.util.Base64.DEFAULT))
            println("   - X-VaxHub-Identifier (decoded): $decoded")
        } catch (e: Exception) {
            println("   - Could not decode X-VaxHub-Identifier: ${e.message}")
        }
    }

    @After
    fun tearDown() {
        // Close activity
        scenario.close()
        
        // Shutdown mock server if running
        if (BuildConfig.BUILD_TYPE == "local") {
            try {
                mockServer.shutdown()
            } catch (e: Exception) {
                // Mock server might not be initialized
            }
        }
        
        // Note: We don't clear localStorage here to maintain session across tests
        // If you need a clean state between tests, uncomment the line below
        // storageUtil.clearLocalStorageAndDatabase()
    }



    /**
     * Test successful checkout with single vaccine
     *
     * This test verifies:
     * - Appointment is created successfully
     * - Checkout API call completes successfully
     * - Single vaccine is administered correctly
     * - Checkout status is updated
     */
    @Test
    fun checkoutAppointment_Success_SingleVaccine() = runBlocking {
        // Verify dependencies are initialized
        Assert.assertNotNull("PatientsApi should not be null", patientsApi)
        Assert.assertNotNull("StorageUtil should not be null", storageUtil)
        Assert.assertNotNull("PatientUtil should not be null", patientUtil)

        // Arrange
        val testPatient = TestPatients.RiskFreePatientForCheckout()
        val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(testPatient)

        // Verify appointment was created successfully
        Assert.assertNotNull("Appointment ID should not be null", appointmentId)
        Assert.assertTrue("Appointment ID should be numeric", appointmentId.matches(Regex("\\d+")))

        val administeredVaccines = listOf(
            CheckInVaccination(
                id = 1,
                productId = testProductVaricella.id,
                ageIndicated = true,
                lotNumber = testProductVaricella.lotNumber,
                method = "Intramuscular",
                site = testSite.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            )
        )

        val checkoutRequest = AppointmentCheckout(
            tabletId = "550e8400-e29b-41d4-a716-446655440001",
            administeredVaccines = administeredVaccines,
            administered = LocalDateTime.now(),
            administeredBy = 1,
            presentedRiskAssessmentId = null,
            forcedRiskType = 0,
            postShotVisitPaymentModeDisplayed = PaymentMode.InsurancePay,
            phoneNumberFlowPresented = false,
            phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
            phoneContactReasons = "",
            flags = emptyList(),
            pregnancyPrompt = false,
            weeksPregnant = null,
            creditCardInformation = null,
            activeFeatureFlags = emptyList(),
            attestHighRisk = false,
            riskFactors = emptyList()
        )

        // Act
        val response = patientsApi.checkoutAppointment(
            appointmentId = appointmentId.toInt(),
            appointmentCheckout = checkoutRequest,
            ignoreOfflineStorage = true
        )

        // Assert
        Assert.assertTrue("Checkout should be successful", response.isSuccessful)
        Assert.assertEquals("Response code should be 200", 200, response.code())

        // Verify appointment status after checkout
        val appointment = patientUtil.getAppointmentById(appointmentId)
        Assert.assertNotNull("Appointment should still be retrievable after checkout", appointment)
    }

    /**
     * Test successful checkout with multiple vaccines
     *
     * This test verifies:
     * - Multiple vaccines can be administered in one checkout
     * - Different vaccine types are handled correctly
     * - Payment modes can vary per vaccine
     */
    @Test
    fun checkoutAppointment_Success_MultipleVaccines() = runBlocking {
        // Arrange
        val testPatient = TestPatients.RiskFreePatientForCheckout()
        val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(testPatient)

        val administeredVaccines = listOf(
            CheckInVaccination(
                id = 1,
                productId = testProductVaricella.id,
                ageIndicated = true,
                lotNumber = testProductVaricella.lotNumber,
                method = "Intramuscular",
                site = TestSites.RightArm.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            ),
            CheckInVaccination(
                id = 2,
                productId = testProductAdacel.id,
                ageIndicated = true,
                lotNumber = testProductAdacel.lotNumber,
                method = "Intramuscular",
                site = TestSites.LeftArm.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            ),
            CheckInVaccination(
                id = 3,
                productId = testProductPPSV23.id,
                ageIndicated = true,
                lotNumber = testProductPPSV23.lotNumber,
                method = "Intramuscular",
                site = TestSites.RightArm.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            )
        )

        val checkoutRequest = AppointmentCheckout(
            tabletId = "550e8400-e29b-41d4-a716-446655440002",
            administeredVaccines = administeredVaccines,
            administered = LocalDateTime.now(),
            administeredBy = 1,
            presentedRiskAssessmentId = null,
            forcedRiskType = 0,
            postShotVisitPaymentModeDisplayed = PaymentMode.InsurancePay,
            phoneNumberFlowPresented = false,
            phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
            phoneContactReasons = "",
            flags = emptyList(),
            pregnancyPrompt = false,
            weeksPregnant = null,
            creditCardInformation = null,
            activeFeatureFlags = emptyList(),
            attestHighRisk = false,
            riskFactors = emptyList()
        )

        // Act
        val response = patientsApi.checkoutAppointment(
            appointmentId = appointmentId.toInt(),
            appointmentCheckout = checkoutRequest,
            ignoreOfflineStorage = true
        )

        // Assert
        Assert.assertTrue("Multiple vaccine checkout should be successful", response.isSuccessful)
        Assert.assertEquals("Response code should be 200", 200, response.code())
    }

    /**
     * Test checkout with self-pay patient
     *
     * This test verifies:
     * - Self-pay patients can be checked out
     * - Self-pay payment mode is handled correctly
     * - Credit card information can be included
     */
    @Test
    fun checkoutAppointment_Success_SelfPayPatient() = runBlocking {
        // Arrange
        val selfPayPatient = TestPatients.SelfPayPatient()
        val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(selfPayPatient)

        val administeredVaccines = listOf(
            CheckInVaccination(
                id = 1,
                productId = testProductVaricella.id,
                ageIndicated = true,
                lotNumber = testProductVaricella.lotNumber,
                method = "Intramuscular",
                site = testSite.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.SelfPay,
                paymentModeReason = null
            )
        )

        val creditCardInfo = PaymentInformationRequestBody(
            cardNumber = "4111111111111111",
            expirationDate = "12/2025",
            cardholderName = "John Doe",
            email = "john.doe@example.com",
            phoneNumber = "1234567890"
        )

        val checkoutRequest = AppointmentCheckout(
            tabletId = "550e8400-e29b-41d4-a716-446655440003",
            administeredVaccines = administeredVaccines,
            administered = LocalDateTime.now(),
            administeredBy = 1,
            presentedRiskAssessmentId = null,
            forcedRiskType = 0,
            postShotVisitPaymentModeDisplayed = PaymentMode.SelfPay,
            phoneNumberFlowPresented = false,
            phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
            phoneContactReasons = "",
            flags = emptyList(),
            pregnancyPrompt = false,
            weeksPregnant = null,
            creditCardInformation = creditCardInfo,
            activeFeatureFlags = emptyList(),
            attestHighRisk = false,
            riskFactors = emptyList()
        )

        // Act
        val response = patientsApi.checkoutAppointment(
            appointmentId = appointmentId.toInt(),
            appointmentCheckout = checkoutRequest,
            ignoreOfflineStorage = true
        )

        // Assert
        Assert.assertTrue("Self-pay checkout should be successful", response.isSuccessful)
        Assert.assertEquals("Response code should be 200", 200, response.code())
    }

    /**
     * Test checkout with VFC patient
     *
     * This test verifies:
     * - VFC patients can be checked out
     * - VFC payment mode is handled correctly
     * - No payment information is required
     */
    @Test
    fun checkoutAppointment_Success_VFCPatient() = runBlocking {
        // Arrange
        val vfcPatient = TestPatients.VFCPatient()
        val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(vfcPatient)

        val administeredVaccines = listOf(
            CheckInVaccination(
                id = 1,
                productId = testProductVaricella.id,
                ageIndicated = true,
                lotNumber = testProductVaricella.lotNumber,
                method = "Intramuscular",
                site = testSite.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.NoPay,
                paymentModeReason = null
            )
        )

        val checkoutRequest = AppointmentCheckout(
            tabletId = "550e8400-e29b-41d4-a716-446655440004",
            administeredVaccines = administeredVaccines,
            administered = LocalDateTime.now(),
            administeredBy = 1,
            presentedRiskAssessmentId = null,
            forcedRiskType = 0,
            postShotVisitPaymentModeDisplayed = PaymentMode.NoPay,
            phoneNumberFlowPresented = false,
            phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
            phoneContactReasons = "",
            flags = emptyList(),
            pregnancyPrompt = false,
            weeksPregnant = null,
            creditCardInformation = null,
            activeFeatureFlags = emptyList(),
            attestHighRisk = false,
            riskFactors = emptyList()
        )

        // Act
        val response = patientsApi.checkoutAppointment(
            appointmentId = appointmentId.toInt(),
            appointmentCheckout = checkoutRequest,
            ignoreOfflineStorage = true
        )

        // Assert
        Assert.assertTrue("VFC checkout should be successful", response.isSuccessful)
        Assert.assertEquals("Response code should be 200", 200, response.code())
    }

    /**
     * Test checkout with pregnant patient
     *
     * This test verifies:
     * - Pregnant patients can be checked out
     * - Pregnancy information is handled correctly
     * - Pregnancy-specific flags are set
     */
    @Test
    fun checkoutAppointment_Success_PregnantPatient() = runBlocking {
        // Arrange
        val pregnantPatient = TestPatients.PregnantPatient()
        val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(pregnantPatient)

        val administeredVaccines = listOf(
            CheckInVaccination(
                id = 1,
                productId = testProductVaricella.id,
                ageIndicated = true,
                lotNumber = testProductVaricella.lotNumber,
                method = "Intramuscular",
                site = testSite.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            )
        )

        val checkoutRequest = AppointmentCheckout(
            tabletId = "550e8400-e29b-41d4-a716-446655440005",
            administeredVaccines = administeredVaccines,
            administered = LocalDateTime.now(),
            administeredBy = 1,
            presentedRiskAssessmentId = null,
            forcedRiskType = 0,
            postShotVisitPaymentModeDisplayed = PaymentMode.InsurancePay,
            phoneNumberFlowPresented = false,
            phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
            phoneContactReasons = "",
            flags = listOf("PREGNANCY"),
            pregnancyPrompt = true,
            weeksPregnant = 20,
            creditCardInformation = null,
            activeFeatureFlags = emptyList(),
            attestHighRisk = false,
            riskFactors = listOf(RiskFactor.RSV_PREGNANT)
        )

        // Act
        val response = patientsApi.checkoutAppointment(
            appointmentId = appointmentId.toInt(),
            appointmentCheckout = checkoutRequest,
            ignoreOfflineStorage = true
        )

        // Assert
        Assert.assertTrue("Pregnant patient checkout should be successful", response.isSuccessful)
        Assert.assertEquals("Response code should be 200", 200, response.code())
    }

    /**
     * Test checkout with high-risk patient
     *
     * This test verifies:
     * - High-risk patients can be checked out
     * - Risk factors are properly recorded
     * - High-risk attestation is handled
     */
    @Test
    fun checkoutAppointment_Success_HighRiskPatient() = runBlocking {
        // Arrange
        val testPatient = TestPatients.RiskFreePatientForCheckout()
        val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(testPatient)

        val administeredVaccines = listOf(
            CheckInVaccination(
                id = 1,
                productId = testProductVaricella.id,
                ageIndicated = true,
                lotNumber = testProductVaricella.lotNumber,
                method = "Intramuscular",
                site = testSite.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            )
        )

        val checkoutRequest = AppointmentCheckout(
            tabletId = "550e8400-e29b-41d4-a716-446655440006",
            administeredVaccines = administeredVaccines,
            administered = LocalDateTime.now(),
            administeredBy = 1,
            presentedRiskAssessmentId = 1,
            forcedRiskType = 1,
            postShotVisitPaymentModeDisplayed = PaymentMode.InsurancePay,
            phoneNumberFlowPresented = false,
            phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
            phoneContactReasons = "",
            flags = listOf("PatientContactPhoneOptIn"),
            pregnancyPrompt = false,
            weeksPregnant = null,
            creditCardInformation = null,
            activeFeatureFlags = emptyList(),
            attestHighRisk = true,
            riskFactors = listOf(RiskFactor.COVID_UNDER_65, RiskFactor.RSV_PREGNANT)
        )

        // Act
        val response = patientsApi.checkoutAppointment(
            appointmentId = appointmentId.toInt(),
            appointmentCheckout = checkoutRequest,
            ignoreOfflineStorage = true
        )

        // Assert
        Assert.assertTrue("High-risk patient checkout should be successful", response.isSuccessful)
        Assert.assertEquals("Response code should be 200", 200, response.code())
    }

    /**
     * Test checkout with different administration methods
     *
     * This test verifies:
     * - Different administration methods are supported
     * - Method information is properly recorded
     * - Site information is correctly associated
     */
    @Test
    fun checkoutAppointment_Success_DifferentAdministrationMethods() = runBlocking {
        // Arrange
        val testPatient = TestPatients.RiskFreePatientForCheckout()
        val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(testPatient)

        val administeredVaccines = listOf(
            CheckInVaccination(
                id = 1,
                productId = testProductVaricella.id,
                ageIndicated = true,
                lotNumber = testProductVaricella.lotNumber,
                method = "Intramuscular",
                site = TestSites.RightArm.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            ),
            CheckInVaccination(
                id = 2,
                productId = testProductAdacel.id,
                ageIndicated = true,
                lotNumber = testProductAdacel.lotNumber,
                method = "Subcutaneous",
                site = TestSites.LeftArm.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            )
        )

        val checkoutRequest = AppointmentCheckout(
            tabletId = "550e8400-e29b-41d4-a716-446655440008",
            administeredVaccines = administeredVaccines,
            administered = LocalDateTime.now(),
            administeredBy = 1,
            presentedRiskAssessmentId = null,
            forcedRiskType = 0,
            postShotVisitPaymentModeDisplayed = PaymentMode.InsurancePay,
            phoneNumberFlowPresented = false,
            phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
            phoneContactReasons = "",
            flags = emptyList(),
            pregnancyPrompt = false,
            weeksPregnant = null,
            creditCardInformation = null,
            activeFeatureFlags = emptyList(),
            attestHighRisk = false,
            riskFactors = emptyList()
        )

        // Act
        val response = patientsApi.checkoutAppointment(
            appointmentId = appointmentId.toInt(),
            appointmentCheckout = checkoutRequest,
            ignoreOfflineStorage = true
        )

        // Assert
        Assert.assertTrue("Different administration methods checkout should be successful", response.isSuccessful)
        Assert.assertEquals("Response code should be 200", 200, response.code())
    }

    /**
     * Test checkout with different dose series
     *
     * This test verifies:
     * - Different dose series are supported
     * - Series information is properly recorded
     * - Multiple doses of the same vaccine are handled
     */
    @Test
    fun checkoutAppointment_Success_DifferentDoseSeries() = runBlocking {
        // Arrange
        val testPatient = TestPatients.RiskFreePatientForCheckout()
        val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(testPatient)

        val administeredVaccines = listOf(
            CheckInVaccination(
                id = 1,
                productId = testProductVaricella.id,
                ageIndicated = true,
                lotNumber = testProductVaricella.lotNumber,
                method = "Intramuscular",
                site = TestSites.RightArm.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            ),
            CheckInVaccination(
                id = 2,
                productId = testProductVaricella.id,
                ageIndicated = true,
                lotNumber = testProductVaricella.lotNumber,
                method = "Intramuscular",
                site = TestSites.LeftArm.displayName,
                doseSeries = 2,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            )
        )

        val checkoutRequest = AppointmentCheckout(
            tabletId = "550e8400-e29b-41d4-a716-446655440009",
            administeredVaccines = administeredVaccines,
            administered = LocalDateTime.now(),
            administeredBy = 1,
            presentedRiskAssessmentId = null,
            forcedRiskType = 0,
            postShotVisitPaymentModeDisplayed = PaymentMode.InsurancePay,
            phoneNumberFlowPresented = false,
            phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
            phoneContactReasons = "",
            flags = emptyList(),
            pregnancyPrompt = false,
            weeksPregnant = null,
            creditCardInformation = null,
            activeFeatureFlags = emptyList(),
            attestHighRisk = false,
            riskFactors = emptyList()
        )

        // Act
        val response = patientsApi.checkoutAppointment(
            appointmentId = appointmentId.toInt(),
            appointmentCheckout = checkoutRequest,
            ignoreOfflineStorage = true
        )

        // Assert
        Assert.assertTrue("Different dose series checkout should be successful", response.isSuccessful)
        Assert.assertEquals("Response code should be 200", 200, response.code())
    }

    /**
     * Test checkout with feature flags
     *
     * This test verifies:
     * - Feature flags are properly handled
     * - Active feature flags are recorded
     * - Feature-specific behavior is supported
     */
    @Test
    fun checkoutAppointment_Success_WithFeatureFlags() = runBlocking {
        // Arrange
        val testPatient = TestPatients.RiskFreePatientForCheckout()
        val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(testPatient)

        val administeredVaccines = listOf(
            CheckInVaccination(
                id = 1,
                productId = testProductVaricella.id,
                ageIndicated = true,
                lotNumber = testProductVaricella.lotNumber,
                method = "Intramuscular",
                site = testSite.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            )
        )

        val checkoutRequest = AppointmentCheckout(
            tabletId = "550e8400-e29b-41d4-a716-446655440010",
            administeredVaccines = administeredVaccines,
            administered = LocalDateTime.now(),
            administeredBy = 1,
            presentedRiskAssessmentId = null,
            forcedRiskType = 0,
            postShotVisitPaymentModeDisplayed = PaymentMode.InsurancePay,
            phoneNumberFlowPresented = false,
            phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
            phoneContactReasons = "",
            flags = listOf("FEATURE_FLAG_1", "FEATURE_FLAG_2"),
            pregnancyPrompt = false,
            weeksPregnant = null,
            creditCardInformation = null,
            activeFeatureFlags = listOf("ENHANCED_CHECKOUT", "RISK_ASSESSMENT"),
            attestHighRisk = false,
            riskFactors = emptyList()
        )

        // Act
        val response = patientsApi.checkoutAppointment(
            appointmentId = appointmentId.toInt(),
            appointmentCheckout = checkoutRequest,
            ignoreOfflineStorage = true
        )

        // Assert
        Assert.assertTrue("Feature flags checkout should be successful", response.isSuccessful)
        Assert.assertEquals("Response code should be 200", 200, response.code())
    }

    /**
     * Test checkout with invalid appointment ID
     *
     * This test verifies:
     * - Invalid appointment IDs are handled gracefully
     * - Appropriate error responses are returned
     * - System remains stable with invalid inputs
     */
    @Test
    fun checkoutAppointment_Error_InvalidAppointmentId() = runBlocking {
        // Arrange
        val invalidAppointmentId = 999999
        val administeredVaccines = listOf(
            CheckInVaccination(
                id = 1,
                productId = testProductVaricella.id,
                ageIndicated = true,
                lotNumber = testProductVaricella.lotNumber,
                method = "Intramuscular",
                site = testSite.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            )
        )

        val checkoutRequest = AppointmentCheckout(
            tabletId = "550e8400-e29b-41d4-a716-446655440011",
            administeredVaccines = administeredVaccines,
            administered = LocalDateTime.now(),
            administeredBy = 1,
            presentedRiskAssessmentId = null,
            forcedRiskType = 0,
            postShotVisitPaymentModeDisplayed = PaymentMode.InsurancePay,
            phoneNumberFlowPresented = false,
            phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
            phoneContactReasons = "",
            flags = emptyList(),
            pregnancyPrompt = false,
            weeksPregnant = null,
            creditCardInformation = null,
            activeFeatureFlags = emptyList(),
            attestHighRisk = false,
            riskFactors = emptyList()
        )

        // Act
        val response = patientsApi.checkoutAppointment(
            appointmentId = invalidAppointmentId,
            appointmentCheckout = checkoutRequest,
            ignoreOfflineStorage = true
        )

        // Assert
        Assert.assertFalse("Invalid appointment ID should result in error", response.isSuccessful)
        Assert.assertTrue("Response code should be 4xx or 5xx", response.code() >= 400)
    }

    /**
     * Test checkout with empty vaccine list
     *
     * This test verifies:
     * - Empty vaccine lists are handled appropriately
     * - System behavior with no administered vaccines
     * - Edge case handling
     */
    @Test
    fun checkoutAppointment_Success_EmptyVaccineList() = runBlocking {
        // Arrange
        val testPatient = TestPatients.RiskFreePatientForCheckout()
        val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(testPatient)

        val checkoutRequest = AppointmentCheckout(
            tabletId = "550e8400-e29b-41d4-a716-446655440012",
            administeredVaccines = emptyList(),
            administered = LocalDateTime.now(),
            administeredBy = 1,
            presentedRiskAssessmentId = null,
            forcedRiskType = 0,
            postShotVisitPaymentModeDisplayed = PaymentMode.InsurancePay,
            phoneNumberFlowPresented = false,
            phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
            phoneContactReasons = "",
            flags = emptyList(),
            pregnancyPrompt = false,
            weeksPregnant = null,
            creditCardInformation = null,
            activeFeatureFlags = emptyList(),
            attestHighRisk = false,
            riskFactors = emptyList()
        )

        // Act
        val response = patientsApi.checkoutAppointment(
            appointmentId = appointmentId.toInt(),
            appointmentCheckout = checkoutRequest,
            ignoreOfflineStorage = true
        )

        // Assert
        // Note: This might be successful or fail depending on business rules
        // The test verifies the system handles this scenario appropriately
        Assert.assertNotNull("Response should not be null", response)
    }

    /**
     * Test bypassing UI login completely
     * 
     * This test verifies that we can create appointments and perform checkout
     * without any UI interaction using only X-VaxHub-Identifier and UserSessionId
     */
    @Test
    fun testBypassUILogin() = runBlocking {
        // Session and X-VaxHub-Identifier already created in @Before
        val sessionId = userSessionService.getCurrentUserSessionId()
        Assert.assertNotNull("User session should be created", sessionId)
        println("‚úÖ Using session from setup: $sessionId")
        println("‚úÖ X-VaxHub-Identifier auto-added to all requests")
        
        // Test that we can create an appointment with this session
        val testPatient = TestPatients.RiskFreePatientForCheckout()
        val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(testPatient)
        
        // Verify appointment was created successfully
        Assert.assertNotNull("Appointment ID should not be null", appointmentId)
        Assert.assertTrue("Appointment ID should be numeric", appointmentId.matches(Regex("\\d+")))
        
        println("‚úÖ Appointment created without UI login: $appointmentId")
        
        // Test checkout with the created appointment
        val administeredVaccines = listOf(
            CheckInVaccination(
                id = 1,
                productId = testProductVaricella.id,
                ageIndicated = true,
                lotNumber = testProductVaricella.lotNumber,
                method = "Intramuscular",
                site = testSite.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            )
        )

        val checkoutRequest = AppointmentCheckout(
            tabletId = "550e8400-e29b-41d4-a716-446655440013",
            administeredVaccines = administeredVaccines,
            administered = LocalDateTime.now(),
            administeredBy = 1,
            presentedRiskAssessmentId = null,
            forcedRiskType = 0,
            postShotVisitPaymentModeDisplayed = PaymentMode.InsurancePay,
            phoneNumberFlowPresented = false,
            phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
            phoneContactReasons = "",
            flags = emptyList(),
            pregnancyPrompt = false,
            weeksPregnant = null,
            creditCardInformation = null,
            activeFeatureFlags = emptyList(),
            attestHighRisk = false,
            riskFactors = emptyList()
        )

        // Act - Perform checkout
        try {
            val response = patientsApi.checkoutAppointment(
                appointmentId = appointmentId.toInt(),
                appointmentCheckout = checkoutRequest,
                ignoreOfflineStorage = true
            )

            // Assert
            Assert.assertTrue("Checkout should be successful without UI login", response.isSuccessful)
            Assert.assertEquals("Response code should be 200", 200, response.code())
            
            println("‚úÖ Checkout completed successfully without UI login")
            
        } catch (e: Exception) {
            println("‚ùå Checkout failed without UI login: ${e.message}")
            println("Exception type: ${e.javaClass.simpleName}")
            if (e is retrofit2.HttpException) {
                println("HTTP Code: ${e.code()}")
                println("HTTP Message: ${e.message()}")
                try {
                    val errorBody = e.response()?.errorBody()?.string()
                    println("Response Body: $errorBody")
                    
                    // Additional debugging for 500 errors
                    if (e.code() == 500) {
                        println("üîç HTTP 500 Debug Info:")
                        println("- Request URL: ${e.response()?.raw()?.request?.url}")
                        println("- Request Method: ${e.response()?.raw()?.request?.method}")
                        println("- Request Headers: ${e.response()?.raw()?.request?.headers}")
                        println("- Response Headers: ${e.response()?.raw()?.headers}")
                    }
                } catch (bodyException: Exception) {
                    println("Could not read error body: ${bodyException.message}")
                }
            }
            throw e
        }
    }

    /**
     * Test to debug HTTP 500 errors
     * 
     * This test helps identify what's causing the 500 error by testing
     * each step of the process separately
     */
    @Test
    fun testDebugHttp500Error() = runBlocking {
        println("üîç Starting HTTP 500 Debug Test...")
        
        // Step 1: Verify session from setup
        try {
            val sessionId = userSessionService.getCurrentUserSessionId()
            Assert.assertNotNull("Session should exist from setup", sessionId)
            println("‚úÖ Step 1 - Session verified: $sessionId")
        } catch (e: Exception) {
            println("‚ùå Step 1 - Session verification failed: ${e.message}")
            throw e
        }
        
        // Step 2: Test appointment creation
        try {
            val testPatient = TestPatients.RiskFreePatientForCheckout()
            val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(testPatient)
            println("‚úÖ Step 2 - Appointment created: $appointmentId")
            
            // Step 3: Test appointment retrieval
            val appointment = patientUtil.getAppointmentById(appointmentId)
            println("‚úÖ Step 3 - Appointment retrieved: ${appointment?.id}")
            
        } catch (e: Exception) {
            println("‚ùå Step 2/3 - Appointment creation/retrieval failed: ${e.message}")
            if (e is retrofit2.HttpException) {
                println("HTTP Code: ${e.code()}")
                println("HTTP Message: ${e.message()}")
                try {
                    val errorBody = e.response()?.errorBody()?.string()
                    println("Response Body: $errorBody")
                    
                    if (e.code() == 500) {
                        println("üîç HTTP 500 in Appointment Creation:")
                        println("- Request URL: ${e.response()?.raw()?.request?.url}")
                        println("- Request Method: ${e.response()?.raw()?.request?.method}")
                        println("- Request Headers: ${e.response()?.raw()?.request?.headers}")
                    }
                } catch (bodyException: Exception) {
                    println("Could not read error body: ${bodyException.message}")
                }
            }
            throw e
        }
        
        // Step 4: Test simple checkout (minimal data)
        try {
            val testPatient = TestPatients.RiskFreePatientForCheckout()
            val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(testPatient)
            
            val minimalCheckoutRequest = AppointmentCheckout(
                tabletId = "550e8400-e29b-41d4-a716-446655440014",
                administeredVaccines = emptyList(), // Empty list to minimize complexity
                administered = LocalDateTime.now(),
                administeredBy = 1,
                presentedRiskAssessmentId = null,
                forcedRiskType = 0,
                postShotVisitPaymentModeDisplayed = PaymentMode.InsurancePay,
                phoneNumberFlowPresented = false,
                phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
                phoneContactReasons = "",
                flags = emptyList(),
                pregnancyPrompt = false,
                weeksPregnant = null,
                creditCardInformation = null,
                activeFeatureFlags = emptyList(),
                attestHighRisk = false,
                riskFactors = emptyList()
            )
            
            val response = patientsApi.checkoutAppointment(
                appointmentId = appointmentId.toInt(),
                appointmentCheckout = minimalCheckoutRequest,
                ignoreOfflineStorage = true
            )
            
            println("‚úÖ Step 4 - Minimal checkout successful: ${response.code()}")
            
        } catch (e: Exception) {
            println("‚ùå Step 4 - Minimal checkout failed: ${e.message}")
            if (e is retrofit2.HttpException) {
                println("HTTP Code: ${e.code()}")
                println("HTTP Message: ${e.message()}")
                try {
                    val errorBody = e.response()?.errorBody()?.string()
                    println("Response Body: $errorBody")
                    
                    if (e.code() == 500) {
                        println("üîç HTTP 500 in Checkout:")
                        println("- Request URL: ${e.response()?.raw()?.request?.url}")
                        println("- Request Method: ${e.response()?.raw()?.request?.method}")
                        println("- Request Headers: ${e.response()?.raw()?.request?.headers}")
                        println("- Request Body: ${e.response()?.raw()?.request?.body?.toString()}")
                    }
                } catch (bodyException: Exception) {
                    println("Could not read error body: ${bodyException.message}")
                }
            }
            throw e
        }
        
        println("üéâ All steps completed successfully!")
    }

    /**
     * Test checkout using X-VaxHub-Identifier and UserSessionId
     * 
     * This test demonstrates how to perform checkout using only:
     * 1. X-VaxHub-Identifier (auto-generated, never expires)
     * 2. UserSessionId (generated in setup)
     * No UI interaction required!
     */
    @Test
    fun testCheckoutWithUserSession() = runBlocking {
        println("üöÄ Starting X-VaxHub-Identifier Checkout Test...")
        
        // Step 1: Verify session from setup
        val sessionId = userSessionService.getCurrentUserSessionId()
        Assert.assertNotNull("User session should be created", sessionId)
        println("‚úÖ Using session from setup: $sessionId")
        println("‚úÖ X-VaxHub-Identifier: Auto-added to all requests")
        
        // Step 2: Create appointment using the session
        val testPatient = TestPatients.RiskFreePatientForCheckout()
        val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(testPatient)
        Assert.assertNotNull("Appointment should be created", appointmentId)
        println("‚úÖ Appointment created: $appointmentId")
        
        // Step 3: Verify appointment exists
        val appointment = patientUtil.getAppointmentById(appointmentId)
        Assert.assertNotNull("Appointment should be retrievable", appointment)
        println("‚úÖ Appointment verified: ${appointment?.id}")
        
        // Step 4: Perform checkout with comprehensive vaccine data
        val administeredVaccines = listOf(
            CheckInVaccination(
                id = 1,
                productId = testProductVaricella.id,
                ageIndicated = true,
                lotNumber = testProductVaricella.lotNumber,
                method = "Intramuscular",
                site = testSite.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            ),
            CheckInVaccination(
                id = 2,
                productId = testProductAdacel.id,
                ageIndicated = true,
                lotNumber = testProductAdacel.lotNumber,
                method = "Intramuscular",
                site = TestSites.LeftArm.displayName,
                doseSeries = 1,
                paymentMode = PaymentMode.InsurancePay,
                paymentModeReason = null
            )
        )

        val checkoutRequest = AppointmentCheckout(
            tabletId = "550e8400-e29b-41d4-a716-446655440015",
            administeredVaccines = administeredVaccines,
            administered = LocalDateTime.now(),
            administeredBy = 1,
            presentedRiskAssessmentId = null,
            forcedRiskType = 0,
            postShotVisitPaymentModeDisplayed = PaymentMode.InsurancePay,
            phoneNumberFlowPresented = false,
            phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
            phoneContactReasons = "",
            flags = listOf("PatientContactPhoneOptIn"),
            pregnancyPrompt = false,
            weeksPregnant = null,
            creditCardInformation = null,
            activeFeatureFlags = listOf("ENHANCED_CHECKOUT"),
            attestHighRisk = false,
            riskFactors = listOf(RiskFactor.COVID_UNDER_65)
        )

        // Step 5: Execute checkout
        try {
            val response = patientsApi.checkoutAppointment(
                appointmentId = appointmentId.toInt(),
                appointmentCheckout = checkoutRequest,
                ignoreOfflineStorage = true
            )

            // Step 6: Verify checkout success
            Assert.assertTrue("Checkout should be successful", response.isSuccessful)
            Assert.assertEquals("Response code should be 200", 200, response.code())
            println("‚úÖ Checkout completed successfully with user session")
            
            // Step 7: Verify appointment state after checkout
            val updatedAppointment = patientUtil.getAppointmentById(appointmentId)
            Assert.assertNotNull("Appointment should still exist after checkout", updatedAppointment)
            println("‚úÖ Appointment state verified after checkout")
            
        } catch (e: Exception) {
            println("‚ùå Checkout failed with user session: ${e.message}")
            if (e is retrofit2.HttpException) {
                println("HTTP Code: ${e.code()}")
                println("HTTP Message: ${e.message()}")
                try {
                    val errorBody = e.response()?.errorBody()?.string()
                    println("Response Body: $errorBody")
                } catch (bodyException: Exception) {
                    println("Could not read error body: ${bodyException.message}")
                }
            }
            throw e
        }
        
        println("üéâ User session checkout test completed successfully!")
    }

    /**
     * Test multiple checkouts with X-VaxHub-Identifier
     * 
     * This test verifies that X-VaxHub-Identifier (which never expires)
     * can handle multiple checkout operations, demonstrating its reusability
     */
    @Test
    fun testMultipleCheckoutsWithSameSession() = runBlocking {
        println("üîÑ Starting Multiple Checkouts Test...")
        
        // Verify session from setup
        try {
            val sessionId = userSessionService.getCurrentUserSessionId()
            Assert.assertNotNull("User session should exist from setup", sessionId)
            println("‚úÖ Using session from setup: $sessionId")
            println("‚úÖ X-VaxHub-Identifier will be reused for all checkouts")
        } catch (e: Exception) {
            println("‚ùå Session verification failed: ${e.message}")
            throw e
        }
        
        // Perform multiple checkouts with the same session
        val patients = listOf(
            TestPatients.RiskFreePatientForCheckout(),
            TestPatients.SelfPayPatient(),
            TestPatients.VFCPatient()
        )
        
        for ((index, patient) in patients.withIndex()) {
            try {
                println("üîÑ Processing checkout ${index + 1}/3 for ${patient.firstName}")
                
                // Verify session is still valid before each operation
                val currentSessionId = userSessionService.getCurrentUserSessionId()
                Assert.assertNotNull("Session should still be valid for checkout ${index + 1}", currentSessionId)
                println("‚úÖ Session verified for checkout ${index + 1}: $currentSessionId")
                
                // Create appointment
                val appointmentId = patientUtil.getAppointmentIdByCreateTestPatient(patient)
                Assert.assertNotNull("Appointment should be created", appointmentId)
                println("‚úÖ Appointment created for ${patient.firstName}: $appointmentId")
                
                // Create checkout request with appropriate payment mode
                val paymentMode = when (patient.paymentMode) {
                    "2" -> PaymentMode.SelfPay
                    "4" -> PaymentMode.NoPay
                    "1" -> PaymentMode.InsurancePay
                    else -> PaymentMode.InsurancePay // Default for RiskFree patients
                }
                println("‚úÖ Payment mode determined for ${patient.firstName}: $paymentMode")
                
                val checkoutRequest = AppointmentCheckout(
                    tabletId = "550e8400-e29b-41d4-a716-4466554400${16 + index}",
                    administeredVaccines = listOf(
                        CheckInVaccination(
                            id = 1,
                            productId = testProductVaricella.id,
                            ageIndicated = true,
                            lotNumber = testProductVaricella.lotNumber,
                            method = "Intramuscular",
                            site = testSite.displayName,
                            doseSeries = 1,
                            paymentMode = paymentMode,
                            paymentModeReason = null
                        )
                    ),
                    administered = LocalDateTime.now(),
                    administeredBy = 1,
                    presentedRiskAssessmentId = null,
                    forcedRiskType = 0,
                    postShotVisitPaymentModeDisplayed = paymentMode,
                    phoneNumberFlowPresented = false,
                    phoneContactConsentStatus = PhoneContactConsentStatus.NOT_APPLICABLE,
                    phoneContactReasons = "",
                    flags = emptyList(),
                    pregnancyPrompt = false,
                    weeksPregnant = null,
                    creditCardInformation = null,
                    activeFeatureFlags = emptyList(),
                    attestHighRisk = false,
                    riskFactors = emptyList()
                )
                
                // Execute checkout
                try {
                    val response = patientsApi.checkoutAppointment(
                        appointmentId = appointmentId.toInt(),
                        appointmentCheckout = checkoutRequest,
                        ignoreOfflineStorage = true
                    )
                    
                    Assert.assertTrue("Checkout ${index + 1} should be successful", response.isSuccessful)
                    println("‚úÖ Checkout ${index + 1} completed for ${patient.firstName}")
                    
                } catch (e: Exception) {
                    println("‚ùå Checkout API call failed for ${patient.firstName}: ${e.message}")
                    if (e is retrofit2.HttpException) {
                        println("HTTP Code: ${e.code()}")
                        println("HTTP Message: ${e.message()}")
                        try {
                            val errorBody = e.response()?.errorBody()?.string()
                            println("Response Body: $errorBody")
                        } catch (bodyException: Exception) {
                            println("Could not read error body: ${bodyException.message}")
                        }
                    }
                    throw e
                }
                
            } catch (e: Exception) {
                println("‚ùå Checkout ${index + 1} failed for ${patient.firstName}: ${e.message}")
                println("Exception type: ${e.javaClass.simpleName}")
                if (e is NullPointerException) {
                    println("üîç NPE Debug Info:")
                    println("- Patient: ${patient.firstName} ${patient.lastName}")
                    println("- Patient paymentMode: ${patient.paymentMode}")
                    println("- Current session: ${userSessionService.getCurrentUserSessionId()}")
                    println("- Stack trace: ${e.stackTrace.joinToString("\n")}")
                }
                throw e
            }
        }
        
        // Verify session is still valid
        try {
            val finalSessionId = userSessionService.getCurrentUserSessionId()
            Assert.assertNotNull("Final session should not be null", finalSessionId)
            println("‚úÖ Session persisted through multiple checkouts: $finalSessionId")
        } catch (e: Exception) {
            println("‚ùå Session verification failed: ${e.message}")
            throw e
        }
        
        println("üéâ Multiple checkouts test completed successfully!")
    }

    /**
     * Setup partner and clinic configuration
     * 
     * This configures the partner and clinic IDs in localStorage,
     * which automatically generates the X-VaxHub-Identifier header
     * (Base64 encoded JSON with partner, clinic, device, tablet info)
     * 
     * The X-VaxHub-Identifier never expires and can be reused forever
     */
    private suspend fun setupPartnerAndClinic(testPartner: TestPartners) {
        println("üîß Setting up partner and clinic...")
        
        try {
            // Validate partner and clinic with the server
            val checkData = webServer.getCheckPartnerAndClinic(
                testPartner.partnerID,
                testPartner.clinicID
            )
            
            if (!checkData.result) {
                throw IllegalStateException("Invalid partner or clinic ID")
            }
            
            // Store partner, clinic, and tablet ID in localStorage
            // This automatically generates the X-VaxHub-Identifier header
            localStorage.saveSetup(
                testPartner.partnerID.toLong(),
                testPartner.clinicID.toLong()
            )
            localStorage.tabletId = checkData.tabletId
            
            println("‚úÖ Partner/Clinic setup complete")
            println("   Partner ID: ${testPartner.partnerID}")
            println("   Clinic ID: ${testPartner.clinicID}")
            println("   Tablet ID: ${checkData.tabletId}")
            println("   X-VaxHub-Identifier will be auto-generated for all requests")
            
        } catch (e: Exception) {
            println("‚ùå Partner/Clinic setup failed: ${e.message}")
            throw e
        }
    }

    /**
     * Generate patient post body for API calls with comprehensive debugging
     * 
     * This method creates a PatientPostBody with detailed logging to help
     * identify any issues with patient data or clinic information
     */
    private fun generatePatientPostBody(patient: TestPatients, visitDate: LocalDateTime): PatientPostBody {
        println("üîç Generating PatientPostBody for ${patient.firstName} ${patient.lastName}")
        
        try {
            // Debug patient data
            println("üìã Patient Data Debug:")
            println("- First Name: ${patient.firstName}")
            println("- Last Name: ${patient.lastName}")
            println("- Date of Birth: ${patient.dateOfBirth}")
            println("- Gender: ${patient.gender}")
            println("- Primary Insurance ID: ${patient.primaryInsuranceId}")
            println("- Primary Member ID: ${patient.primaryMemberId}")
            println("- Primary Group ID: ${patient.primaryGroupId}")
            println("- Payment Mode: ${patient.paymentMode}")
            println("- SSN: ${patient.ssn}")
            
            // Debug clinic information
            val clinicId = getCurrentClinicId()
            println("üè• Clinic Data Debug:")
            println("- Clinic ID: $clinicId")
            
            // Debug visit date
            println("üìÖ Visit Date Debug:")
            println("- Visit Date: $visitDate")
            
            // Create payment information
            val paymentInformation = PatientPostBody.PaymentInformation(
                primaryInsuranceId = patient.primaryInsuranceId,
                primaryMemberId = patient.primaryMemberId,
                primaryGroupId = patient.primaryGroupId,
                uninsured = false
            )
            println("üí≥ Payment Information Debug:")
            println("- Primary Insurance ID: ${paymentInformation.primaryInsuranceId}")
            println("- Primary Member ID: ${paymentInformation.primaryMemberId}")
            println("- Primary Group ID: ${paymentInformation.primaryGroupId}")
            println("- Uninsured: ${paymentInformation.uninsured}")
            
            // Create new patient
            val newPatient = PatientPostBody.NewPatient(
                firstName = patient.firstName,
                lastName = patient.lastName,
                dob = patient.dateOfBirth,
                gender = patient.gender,
                phoneNumber = "1234567890",
                address1 = null,
                address2 = null,
                city = null,
                state = "FL",
                zip = null,
                paymentInformation = paymentInformation,
                race = null,
                ethnicity = null,
                ssn = patient.ssn
            )
            println("üë§ New Patient Debug:")
            println("- First Name: ${newPatient.firstName}")
            println("- Last Name: ${newPatient.lastName}")
            println("- DOB: ${newPatient.dob}")
            println("- Gender: ${newPatient.gender}")
            println("- Phone: ${newPatient.phoneNumber}")
            println("- State: ${newPatient.state}")
            println("- SSN: ${newPatient.ssn}")
            
            // Create patient post body
            val patientPostBody = PatientPostBody(
                newPatient = newPatient,
                clinicId = clinicId,
                date = visitDate,
                providerId = 0,
                initialPaymentMode = patient.paymentMode ?: "1", // Default to InsurancePay ("1")
                visitType = "Well"
            )
            
            println("üì¶ PatientPostBody Debug:")
            println("- Clinic ID: ${patientPostBody.clinicId}")
            println("- Date: ${patientPostBody.date}")
            println("- Provider ID: ${patientPostBody.providerId}")
            println("- Initial Payment Mode: ${patientPostBody.initialPaymentMode}")
            println("- Visit Type: ${patientPostBody.visitType}")
            
            println("‚úÖ PatientPostBody generated successfully")
            return patientPostBody
            
        } catch (e: Exception) {
            println("‚ùå Error generating PatientPostBody: ${e.message}")
            println("Exception type: ${e.javaClass.simpleName}")
            println("Stack trace: ${e.stackTrace.joinToString("\n")}")
            throw e
        }
    }

    /**
     * Get current clinic ID from storage with debugging
     */
    private fun getCurrentClinicId(): Long {
        try {
            println("üîç Getting current clinic ID...")
            val clinicId = localStorage.currentClinicId
            println("‚úÖ Current clinic ID: $clinicId")
            return clinicId
        } catch (e: Exception) {
            println("‚ùå Error getting clinic ID: ${e.message}")
            println("Exception type: ${e.javaClass.simpleName}")
            println("Stack trace: ${e.stackTrace.joinToString("\n")}")
            throw e
        }
    }

    /**
     * Test to debug PatientPostBody generation
     * 
     * This test specifically focuses on debugging the PatientPostBody creation
     * to identify any issues with patient data or clinic information
     */
    @Test
    fun testDebugPatientPostBodyGeneration() = runBlocking {
        println("üîç Starting PatientPostBody Generation Debug Test...")
        
        // Test with different patient types
        val testPatients = listOf(
            TestPatients.RiskFreePatientForCheckout(),
            TestPatients.SelfPayPatient(),
            TestPatients.VFCPatient()
        )
        
        for ((index, patient) in testPatients.withIndex()) {
            try {
                println("\nüîÑ Testing PatientPostBody generation ${index + 1}/3")
                println("Patient: ${patient.firstName} ${patient.lastName}")
                
                val visitDate = LocalDateTime.now()
                val patientPostBody = generatePatientPostBody(patient, visitDate)
                
                // Verify the generated body
                Assert.assertNotNull("PatientPostBody should not be null", patientPostBody)
                Assert.assertNotNull("NewPatient should not be null", patientPostBody.newPatient)
                Assert.assertEquals("First name should match", patient.firstName, patientPostBody.newPatient?.firstName)
                Assert.assertEquals("Last name should match", patient.lastName, patientPostBody.newPatient?.lastName)
                Assert.assertEquals("DOB should match", patient.dateOfBirth, patientPostBody.newPatient?.dob)
                Assert.assertEquals("Gender should match", patient.gender, patientPostBody.newPatient?.gender)
                
                println("‚úÖ PatientPostBody ${index + 1} generated and validated successfully")
                
            } catch (e: Exception) {
                println("‚ùå PatientPostBody generation failed for ${patient.firstName}: ${e.message}")
                println("Exception type: ${e.javaClass.simpleName}")
                if (e is NullPointerException) {
                    println("üîç NPE Debug Info for PatientPostBody:")
                    println("- Patient: ${patient.firstName} ${patient.lastName}")
                    println("- Patient properties: ${patient.javaClass.declaredFields.joinToString { "${it.name}=${it.get(patient)}" }}")
                }
                throw e
            }
        }
        
        println("üéâ PatientPostBody generation debug test completed successfully!")
    }

    /**
     * Mock dispatcher for CheckoutAPI tests
     * Provides mock responses for API calls during testing
     */
    private class CheckoutAPITestsDispatcher : BaseMockDispatcher() {
        override val mockTestDirectory = "CheckoutAPITests/"

        override fun dispatch(request: RecordedRequest): MockResponse {
            return when {
                request.path?.contains("api/patients/appointment") == true && request.method == "POST" -> {
                    // Mock appointment creation response
                    MockResponse()
                        .setResponseCode(200)
                        .setBody("123456") // Mock appointment ID
                }
                request.path?.contains("api/patients/appointment") == true &&
                        request.path?.contains("/checkout") == true && request.method == "PUT" -> {
                    // Mock checkout response
                    MockResponse()
                        .setResponseCode(200)
                        .setBody("{}")
                }
                request.path?.contains("api/patients/appointment") == true &&
                        request.method == "GET" -> {
                    // Mock appointment retrieval response
                    MockResponse()
                        .setResponseCode(200)
                        .setBody("""
                            {
                                "id": 123456,
                                "clinicId": 1,
                                "appointmentTime": "2025-01-15T12:30:00",
                                "patient": {
                                    "id": 789,
                                    "firstName": "Test",
                                    "lastName": "Patient"
                                },
                                "checkedOut": false,
                                "administeredVaccines": []
                            }
                        """.trimIndent())
                }
                else -> {
                    // Default response for other endpoints
                    MockResponse()
                        .setResponseCode(200)
                        .setBody("{}")
                }
            }
        }
    }
}